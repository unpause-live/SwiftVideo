// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Rpc.public.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//SwiftVideo, Copyright 2019 Unpause SAS
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum RpcFeatureType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case transcoder // = 0
  case compositor // = 1
  case subtractor // = 2
  case rtmpOutput // = 3
  case browser // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .transcoder
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .transcoder
    case 1: self = .compositor
    case 2: self = .subtractor
    case 3: self = .rtmpOutput
    case 4: self = .browser
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .transcoder: return 0
    case .compositor: return 1
    case .subtractor: return 2
    case .rtmpOutput: return 3
    case .browser: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RpcFeatureType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [RpcFeatureType] = [
    .transcoder,
    .compositor,
    .subtractor,
    .rtmpOutput,
    .browser,
  ]
}

#endif  // swift(>=4.2)

public struct RpcAssetPermissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sourceType: MediaSourceType = .rtmp

  public var mediaType: MediaType = .video

  public var formats: [MediaFormat] = []

  public var metadata: Dictionary<String,String> = [:]

  public var requestType: RpcAssetPermissionRequest.PermissionRequestType = .write

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PermissionRequestType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case write // = 0
    case read // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .write
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .write
      case 1: self = .read
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .write: return 0
      case .read: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension RpcAssetPermissionRequest.PermissionRequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [RpcAssetPermissionRequest.PermissionRequestType] = [
    .write,
    .read,
  ]
}

#endif  // swift(>=4.2)

public struct RpcAssetPermissionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var granted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RpcComposerCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commands: [RpcComposerCommand.Command] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct StateSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var elementID: String {
      get {return _storage._elementID}
      set {_uniqueStorage()._elementID = newValue}
    }

    public var duration: TimePoint {
      get {return _storage._duration ?? TimePoint()}
      set {_uniqueStorage()._duration = newValue}
    }
    /// Returns true if `duration` has been explicitly set.
    public var hasDuration: Bool {return _storage._duration != nil}
    /// Clears the value of `duration`. Subsequent reads from it will return its default value.
    public mutating func clearDuration() {_uniqueStorage()._duration = nil}

    public var stateID: String {
      get {return _storage._stateID}
      set {_uniqueStorage()._stateID = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Bind {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var assetID: String = String()

    public var elementID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Load {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uri: String = String()

    public var assetID: String = String()

    public var workspaceToken: String = String()

    public var loop: Bool = false

    public var autoplay: Bool = false

    /// default is to keep asset alive after end so you can play() again. Does nothing with loop = true
    public var closeOnEnd: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Text {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: String {
      get {return _storage._value}
      set {_uniqueStorage()._value = newValue}
    }

    public var fontSize: Int32 {
      get {return _storage._fontSize}
      set {_uniqueStorage()._fontSize = newValue}
    }

    public var fontURL: String {
      get {return _storage._fontURL}
      set {_uniqueStorage()._fontURL = newValue}
    }

    public var assetID: String {
      get {return _storage._assetID}
      set {_uniqueStorage()._assetID = newValue}
    }

    public var color: Vec4 {
      get {return _storage._color ?? Vec4()}
      set {_uniqueStorage()._color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    public var hasColor: Bool {return _storage._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    public mutating func clearColor() {_uniqueStorage()._color = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Command {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var after: [RpcComposerCommand.Command] {
      get {return _storage._after}
      set {_uniqueStorage()._after = newValue}
    }

    public var ident: Int32 {
      get {return _storage._ident}
      set {_uniqueStorage()._ident = newValue}
    }

    public var command: OneOf_Command? {
      get {return _storage._command}
      set {_uniqueStorage()._command = newValue}
    }

    public var scene: String {
      get {
        if case .scene(let v)? = _storage._command {return v}
        return String()
      }
      set {_uniqueStorage()._command = .scene(newValue)}
    }

    public var elementState: RpcComposerCommand.StateSet {
      get {
        if case .elementState(let v)? = _storage._command {return v}
        return RpcComposerCommand.StateSet()
      }
      set {_uniqueStorage()._command = .elementState(newValue)}
    }

    public var bind: RpcComposerCommand.Bind {
      get {
        if case .bind(let v)? = _storage._command {return v}
        return RpcComposerCommand.Bind()
      }
      set {_uniqueStorage()._command = .bind(newValue)}
    }

    public var loadFile: RpcComposerCommand.Load {
      get {
        if case .loadFile(let v)? = _storage._command {return v}
        return RpcComposerCommand.Load()
      }
      set {_uniqueStorage()._command = .loadFile(newValue)}
    }

    public var playFile: String {
      get {
        if case .playFile(let v)? = _storage._command {return v}
        return String()
      }
      set {_uniqueStorage()._command = .playFile(newValue)}
    }

    public var stopFile: String {
      get {
        if case .stopFile(let v)? = _storage._command {return v}
        return String()
      }
      set {_uniqueStorage()._command = .stopFile(newValue)}
    }

    public var setText: RpcComposerCommand.Text {
      get {
        if case .setText(let v)? = _storage._command {return v}
        return RpcComposerCommand.Text()
      }
      set {_uniqueStorage()._command = .setText(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Command: Equatable {
      case scene(String)
      case elementState(RpcComposerCommand.StateSet)
      case bind(RpcComposerCommand.Bind)
      case loadFile(RpcComposerCommand.Load)
      case playFile(String)
      case stopFile(String)
      case setText(RpcComposerCommand.Text)

    #if !swift(>=4.1)
      public static func ==(lhs: RpcComposerCommand.Command.OneOf_Command, rhs: RpcComposerCommand.Command.OneOf_Command) -> Bool {
        switch (lhs, rhs) {
        case (.scene(let l), .scene(let r)): return l == r
        case (.elementState(let l), .elementState(let r)): return l == r
        case (.bind(let l), .bind(let r)): return l == r
        case (.loadFile(let l), .loadFile(let r)): return l == r
        case (.playFile(let l), .playFile(let r)): return l == r
        case (.stopFile(let l), .stopFile(let r)): return l == r
        case (.setText(let l), .setText(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

public struct RpcEncodeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var format: MediaFormat {
    get {return _storage._format}
    set {_uniqueStorage()._format = newValue}
  }

  public var bitrate: Int32 {
    get {return _storage._bitrate}
    set {_uniqueStorage()._bitrate = newValue}
  }

  public var keyframeInterval: TimePoint {
    get {return _storage._keyframeInterval ?? TimePoint()}
    set {_uniqueStorage()._keyframeInterval = newValue}
  }
  /// Returns true if `keyframeInterval` has been explicitly set.
  public var hasKeyframeInterval: Bool {return _storage._keyframeInterval != nil}
  /// Clears the value of `keyframeInterval`. Subsequent reads from it will return its default value.
  public mutating func clearKeyframeInterval() {_uniqueStorage()._keyframeInterval = nil}

  public var sampleRate: Int32 {
    get {return _storage._sampleRate}
    set {_uniqueStorage()._sampleRate = newValue}
  }

  public var channelCount: Int32 {
    get {return _storage._channelCount}
    set {_uniqueStorage()._channelCount = newValue}
  }

  public var bitDepth: Int32 {
    get {return _storage._bitDepth}
    set {_uniqueStorage()._bitDepth = newValue}
  }

  /// eg. level, profile
  public var options: Dictionary<String,String> {
    get {return _storage._options}
    set {_uniqueStorage()._options = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct RpcMixerVideoConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: Int32 {
    get {return _storage._width}
    set {_uniqueStorage()._width = newValue}
  }

  public var height: Int32 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var frameDuration: TimePoint {
    get {return _storage._frameDuration ?? TimePoint()}
    set {_uniqueStorage()._frameDuration = newValue}
  }
  /// Returns true if `frameDuration` has been explicitly set.
  public var hasFrameDuration: Bool {return _storage._frameDuration != nil}
  /// Clears the value of `frameDuration`. Subsequent reads from it will return its default value.
  public mutating func clearFrameDuration() {_uniqueStorage()._frameDuration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct RpcMixerAudioConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sampleRate: Int32 = 0

  public var channels: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RpcMakeComposition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newAssetID: String {
    get {return _storage._newAssetID}
    set {_uniqueStorage()._newAssetID = newValue}
  }

  public var chosenInstance: String {
    get {return _storage._chosenInstance}
    set {_uniqueStorage()._chosenInstance = newValue}
  }

  public var outputConfigs: [RpcEncodeConfig] {
    get {return _storage._outputConfigs}
    set {_uniqueStorage()._outputConfigs = newValue}
  }

  public var video: RpcMixerVideoConfig {
    get {return _storage._video ?? RpcMixerVideoConfig()}
    set {_uniqueStorage()._video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  public var hasVideo: Bool {return _storage._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  public mutating func clearVideo() {_uniqueStorage()._video = nil}

  public var audio: RpcMixerAudioConfig {
    get {return _storage._audio ?? RpcMixerAudioConfig()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {_uniqueStorage()._audio = nil}

  public var features: [RpcFeatureType] {
    get {return _storage._features}
    set {_uniqueStorage()._features = newValue}
  }

  public var composition: Composition {
    get {return _storage._composition ?? Composition()}
    set {_uniqueStorage()._composition = newValue}
  }
  /// Returns true if `composition` has been explicitly set.
  public var hasComposition: Bool {return _storage._composition != nil}
  /// Clears the value of `composition`. Subsequent reads from it will return its default value.
  public mutating func clearComposition() {_uniqueStorage()._composition = nil}

  public var epoch: Int64 {
    get {return _storage._epoch}
    set {_uniqueStorage()._epoch = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension RpcFeatureType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "transcoder"),
    1: .same(proto: "compositor"),
    2: .same(proto: "subtractor"),
    3: .same(proto: "rtmpOutput"),
    4: .same(proto: "browser"),
  ]
}

extension RpcAssetPermissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcAssetPermissionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sourceType"),
    2: .same(proto: "mediaType"),
    3: .same(proto: "formats"),
    4: .same(proto: "metadata"),
    5: .same(proto: "requestType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.sourceType)
      case 2: try decoder.decodeSingularEnumField(value: &self.mediaType)
      case 3: try decoder.decodeRepeatedEnumField(value: &self.formats)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata)
      case 5: try decoder.decodeSingularEnumField(value: &self.requestType)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceType != .rtmp {
      try visitor.visitSingularEnumField(value: self.sourceType, fieldNumber: 1)
    }
    if self.mediaType != .video {
      try visitor.visitSingularEnumField(value: self.mediaType, fieldNumber: 2)
    }
    if !self.formats.isEmpty {
      try visitor.visitPackedEnumField(value: self.formats, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 4)
    }
    if self.requestType != .write {
      try visitor.visitSingularEnumField(value: self.requestType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcAssetPermissionRequest, rhs: RpcAssetPermissionRequest) -> Bool {
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs.mediaType != rhs.mediaType {return false}
    if lhs.formats != rhs.formats {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.requestType != rhs.requestType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcAssetPermissionRequest.PermissionRequestType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "write"),
    1: .same(proto: "read"),
  ]
}

extension RpcAssetPermissionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcAssetPermissionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "granted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.granted)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.granted != false {
      try visitor.visitSingularBoolField(value: self.granted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcAssetPermissionResponse, rhs: RpcAssetPermissionResponse) -> Bool {
    if lhs.granted != rhs.granted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcComposerCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcComposerCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commands"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.commands)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commands, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcComposerCommand, rhs: RpcComposerCommand) -> Bool {
    if lhs.commands != rhs.commands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcComposerCommand.StateSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = RpcComposerCommand.protoMessageName + ".StateSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elementId"),
    2: .same(proto: "duration"),
    3: .same(proto: "stateId"),
  ]

  fileprivate class _StorageClass {
    var _elementID: String = String()
    var _duration: TimePoint? = nil
    var _stateID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementID = source._elementID
      _duration = source._duration
      _stateID = source._stateID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._elementID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._duration)
        case 3: try decoder.decodeSingularStringField(value: &_storage._stateID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._elementID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._elementID, fieldNumber: 1)
      }
      if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._stateID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateID, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcComposerCommand.StateSet, rhs: RpcComposerCommand.StateSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementID != rhs_storage._elementID {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._stateID != rhs_storage._stateID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcComposerCommand.Bind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = RpcComposerCommand.protoMessageName + ".Bind"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assetId"),
    2: .same(proto: "elementId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.assetID)
      case 2: try decoder.decodeSingularStringField(value: &self.elementID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetID, fieldNumber: 1)
    }
    if !self.elementID.isEmpty {
      try visitor.visitSingularStringField(value: self.elementID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcComposerCommand.Bind, rhs: RpcComposerCommand.Bind) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.elementID != rhs.elementID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcComposerCommand.Load: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = RpcComposerCommand.protoMessageName + ".Load"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "assetId"),
    3: .same(proto: "workspaceToken"),
    4: .same(proto: "loop"),
    5: .same(proto: "autoplay"),
    6: .same(proto: "closeOnEnd"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uri)
      case 2: try decoder.decodeSingularStringField(value: &self.assetID)
      case 3: try decoder.decodeSingularStringField(value: &self.workspaceToken)
      case 4: try decoder.decodeSingularBoolField(value: &self.loop)
      case 5: try decoder.decodeSingularBoolField(value: &self.autoplay)
      case 6: try decoder.decodeSingularBoolField(value: &self.closeOnEnd)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.assetID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetID, fieldNumber: 2)
    }
    if !self.workspaceToken.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceToken, fieldNumber: 3)
    }
    if self.loop != false {
      try visitor.visitSingularBoolField(value: self.loop, fieldNumber: 4)
    }
    if self.autoplay != false {
      try visitor.visitSingularBoolField(value: self.autoplay, fieldNumber: 5)
    }
    if self.closeOnEnd != false {
      try visitor.visitSingularBoolField(value: self.closeOnEnd, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcComposerCommand.Load, rhs: RpcComposerCommand.Load) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.workspaceToken != rhs.workspaceToken {return false}
    if lhs.loop != rhs.loop {return false}
    if lhs.autoplay != rhs.autoplay {return false}
    if lhs.closeOnEnd != rhs.closeOnEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcComposerCommand.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = RpcComposerCommand.protoMessageName + ".Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "fontSize"),
    3: .same(proto: "fontUrl"),
    4: .same(proto: "assetId"),
    5: .same(proto: "color"),
  ]

  fileprivate class _StorageClass {
    var _value: String = String()
    var _fontSize: Int32 = 0
    var _fontURL: String = String()
    var _assetID: String = String()
    var _color: Vec4? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _fontSize = source._fontSize
      _fontURL = source._fontURL
      _assetID = source._assetID
      _color = source._color
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._value)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._fontSize)
        case 3: try decoder.decodeSingularStringField(value: &_storage._fontURL)
        case 4: try decoder.decodeSingularStringField(value: &_storage._assetID)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._color)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._value.isEmpty {
        try visitor.visitSingularStringField(value: _storage._value, fieldNumber: 1)
      }
      if _storage._fontSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._fontSize, fieldNumber: 2)
      }
      if !_storage._fontURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fontURL, fieldNumber: 3)
      }
      if !_storage._assetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetID, fieldNumber: 4)
      }
      if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcComposerCommand.Text, rhs: RpcComposerCommand.Text) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._fontSize != rhs_storage._fontSize {return false}
        if _storage._fontURL != rhs_storage._fontURL {return false}
        if _storage._assetID != rhs_storage._assetID {return false}
        if _storage._color != rhs_storage._color {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcComposerCommand.Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = RpcComposerCommand.protoMessageName + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "after"),
    2: .same(proto: "ident"),
    3: .same(proto: "scene"),
    4: .same(proto: "elementState"),
    5: .same(proto: "bind"),
    6: .same(proto: "loadFile"),
    7: .same(proto: "playFile"),
    8: .same(proto: "stopFile"),
    9: .same(proto: "setText"),
  ]

  fileprivate class _StorageClass {
    var _after: [RpcComposerCommand.Command] = []
    var _ident: Int32 = 0
    var _command: RpcComposerCommand.Command.OneOf_Command?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _after = source._after
      _ident = source._ident
      _command = source._command
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._after)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._ident)
        case 3:
          if _storage._command != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._command = .scene(v)}
        case 4:
          var v: RpcComposerCommand.StateSet?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .elementState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .elementState(v)}
        case 5:
          var v: RpcComposerCommand.Bind?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .bind(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .bind(v)}
        case 6:
          var v: RpcComposerCommand.Load?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .loadFile(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .loadFile(v)}
        case 7:
          if _storage._command != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._command = .playFile(v)}
        case 8:
          if _storage._command != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._command = .stopFile(v)}
        case 9:
          var v: RpcComposerCommand.Text?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .setText(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .setText(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._after.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._after, fieldNumber: 1)
      }
      if _storage._ident != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ident, fieldNumber: 2)
      }
      switch _storage._command {
      case .scene(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      case .elementState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .bind(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .loadFile(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .playFile(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      case .stopFile(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      case .setText(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcComposerCommand.Command, rhs: RpcComposerCommand.Command) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._after != rhs_storage._after {return false}
        if _storage._ident != rhs_storage._ident {return false}
        if _storage._command != rhs_storage._command {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcEncodeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcEncodeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .same(proto: "bitrate"),
    3: .same(proto: "keyframeInterval"),
    4: .same(proto: "sampleRate"),
    5: .same(proto: "channelCount"),
    6: .same(proto: "bitDepth"),
    7: .same(proto: "options"),
  ]

  fileprivate class _StorageClass {
    var _format: MediaFormat = .avc
    var _bitrate: Int32 = 0
    var _keyframeInterval: TimePoint? = nil
    var _sampleRate: Int32 = 0
    var _channelCount: Int32 = 0
    var _bitDepth: Int32 = 0
    var _options: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _format = source._format
      _bitrate = source._bitrate
      _keyframeInterval = source._keyframeInterval
      _sampleRate = source._sampleRate
      _channelCount = source._channelCount
      _bitDepth = source._bitDepth
      _options = source._options
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._format)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._bitrate)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._keyframeInterval)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._sampleRate)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._channelCount)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._bitDepth)
        case 7: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._options)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._format != .avc {
        try visitor.visitSingularEnumField(value: _storage._format, fieldNumber: 1)
      }
      if _storage._bitrate != 0 {
        try visitor.visitSingularInt32Field(value: _storage._bitrate, fieldNumber: 2)
      }
      if let v = _storage._keyframeInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._sampleRate != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sampleRate, fieldNumber: 4)
      }
      if _storage._channelCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._channelCount, fieldNumber: 5)
      }
      if _storage._bitDepth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._bitDepth, fieldNumber: 6)
      }
      if !_storage._options.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._options, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcEncodeConfig, rhs: RpcEncodeConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._format != rhs_storage._format {return false}
        if _storage._bitrate != rhs_storage._bitrate {return false}
        if _storage._keyframeInterval != rhs_storage._keyframeInterval {return false}
        if _storage._sampleRate != rhs_storage._sampleRate {return false}
        if _storage._channelCount != rhs_storage._channelCount {return false}
        if _storage._bitDepth != rhs_storage._bitDepth {return false}
        if _storage._options != rhs_storage._options {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcMixerVideoConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcMixerVideoConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "frameDuration"),
  ]

  fileprivate class _StorageClass {
    var _width: Int32 = 0
    var _height: Int32 = 0
    var _frameDuration: TimePoint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _width = source._width
      _height = source._height
      _frameDuration = source._frameDuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._width)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._height)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._frameDuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._width != 0 {
        try visitor.visitSingularInt32Field(value: _storage._width, fieldNumber: 1)
      }
      if _storage._height != 0 {
        try visitor.visitSingularInt32Field(value: _storage._height, fieldNumber: 2)
      }
      if let v = _storage._frameDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcMixerVideoConfig, rhs: RpcMixerVideoConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._frameDuration != rhs_storage._frameDuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcMixerAudioConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcMixerAudioConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sampleRate"),
    2: .same(proto: "channels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.sampleRate)
      case 2: try decoder.decodeSingularInt32Field(value: &self.channels)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sampleRate != 0 {
      try visitor.visitSingularInt32Field(value: self.sampleRate, fieldNumber: 1)
    }
    if self.channels != 0 {
      try visitor.visitSingularInt32Field(value: self.channels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcMixerAudioConfig, rhs: RpcMixerAudioConfig) -> Bool {
    if lhs.sampleRate != rhs.sampleRate {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcMakeComposition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcMakeComposition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newAssetId"),
    2: .same(proto: "chosenInstance"),
    3: .same(proto: "outputConfigs"),
    4: .same(proto: "video"),
    5: .same(proto: "audio"),
    6: .same(proto: "features"),
    7: .same(proto: "composition"),
    8: .same(proto: "epoch"),
  ]

  fileprivate class _StorageClass {
    var _newAssetID: String = String()
    var _chosenInstance: String = String()
    var _outputConfigs: [RpcEncodeConfig] = []
    var _video: RpcMixerVideoConfig? = nil
    var _audio: RpcMixerAudioConfig? = nil
    var _features: [RpcFeatureType] = []
    var _composition: Composition? = nil
    var _epoch: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _newAssetID = source._newAssetID
      _chosenInstance = source._chosenInstance
      _outputConfigs = source._outputConfigs
      _video = source._video
      _audio = source._audio
      _features = source._features
      _composition = source._composition
      _epoch = source._epoch
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._newAssetID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._chosenInstance)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._outputConfigs)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._video)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._audio)
        case 6: try decoder.decodeRepeatedEnumField(value: &_storage._features)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._composition)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._epoch)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._newAssetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._newAssetID, fieldNumber: 1)
      }
      if !_storage._chosenInstance.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chosenInstance, fieldNumber: 2)
      }
      if !_storage._outputConfigs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._outputConfigs, fieldNumber: 3)
      }
      if let v = _storage._video {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._features.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._features, fieldNumber: 6)
      }
      if let v = _storage._composition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._epoch != 0 {
        try visitor.visitSingularInt64Field(value: _storage._epoch, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcMakeComposition, rhs: RpcMakeComposition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._newAssetID != rhs_storage._newAssetID {return false}
        if _storage._chosenInstance != rhs_storage._chosenInstance {return false}
        if _storage._outputConfigs != rhs_storage._outputConfigs {return false}
        if _storage._video != rhs_storage._video {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._features != rhs_storage._features {return false}
        if _storage._composition != rhs_storage._composition {return false}
        if _storage._epoch != rhs_storage._epoch {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
