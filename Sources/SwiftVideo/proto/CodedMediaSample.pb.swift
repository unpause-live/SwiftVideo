// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: CodedMediaSample.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//SwiftVideo, Copyright 2019 Unpause SAS
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum MediaType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case video // = 0
  case audio // = 1
  case image // = 2
  case data // = 3
  case subtitle // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .video
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .video
    case 1: self = .audio
    case 2: self = .image
    case 3: self = .data
    case 4: self = .subtitle
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .video: return 0
    case .audio: return 1
    case .image: return 2
    case .data: return 3
    case .subtitle: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MediaType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MediaType] = [
    .video,
    .audio,
    .image,
    .data,
    .subtitle,
  ]
}

#endif  // swift(>=4.2)

public enum MediaFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case avc // = 0
  case hevc // = 1
  case aac // = 2
  case opus // = 3
  case av1 // = 4
  case vp8 // = 5
  case vp9 // = 6
  case uncompressed // = 7

  /// image
  case png // = 8
  case apng // = 9
  case jpg // = 10
  case gif // = 11

  /// data
  case klv // = 12

  /// subtitle
  case srt // = 13
  case webvtt // = 14
  case utf8Text // = 15
  case UNRECOGNIZED(Int)

  public init() {
    self = .avc
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .avc
    case 1: self = .hevc
    case 2: self = .aac
    case 3: self = .opus
    case 4: self = .av1
    case 5: self = .vp8
    case 6: self = .vp9
    case 7: self = .uncompressed
    case 8: self = .png
    case 9: self = .apng
    case 10: self = .jpg
    case 11: self = .gif
    case 12: self = .klv
    case 13: self = .srt
    case 14: self = .webvtt
    case 15: self = .utf8Text
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .avc: return 0
    case .hevc: return 1
    case .aac: return 2
    case .opus: return 3
    case .av1: return 4
    case .vp8: return 5
    case .vp9: return 6
    case .uncompressed: return 7
    case .png: return 8
    case .apng: return 9
    case .jpg: return 10
    case .gif: return 11
    case .klv: return 12
    case .srt: return 13
    case .webvtt: return 14
    case .utf8Text: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MediaFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MediaFormat] = [
    .avc,
    .hevc,
    .aac,
    .opus,
    .av1,
    .vp8,
    .vp9,
    .uncompressed,
    .png,
    .apng,
    .jpg,
    .gif,
    .klv,
    .srt,
    .webvtt,
    .utf8Text,
  ]
}

#endif  // swift(>=4.2)

public enum MediaSourceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case rtmp // = 0
  case webrtc // = 1
  case httpPut // = 2
  case protobuf // = 3
  case httpGet // = 4
  case transcode // = 5
  case composition // = 6
  case web // = 7
  case output // = 8
  case flavor // = 9
  case file // = 10
  case text // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .rtmp
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rtmp
    case 1: self = .webrtc
    case 2: self = .httpPut
    case 3: self = .protobuf
    case 4: self = .httpGet
    case 5: self = .transcode
    case 6: self = .composition
    case 7: self = .web
    case 8: self = .output
    case 9: self = .flavor
    case 10: self = .file
    case 11: self = .text
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .rtmp: return 0
    case .webrtc: return 1
    case .httpPut: return 2
    case .protobuf: return 3
    case .httpGet: return 4
    case .transcode: return 5
    case .composition: return 6
    case .web: return 7
    case .output: return 8
    case .flavor: return 9
    case .file: return 10
    case .text: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MediaSourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MediaSourceType] = [
    .rtmp,
    .webrtc,
    .httpPut,
    .protobuf,
    .httpGet,
    .transcode,
    .composition,
    .web,
    .output,
    .flavor,
    .file,
    .text,
  ]
}

#endif  // swift(>=4.2)

public struct CodedMediaSampleWire {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pts: TimePoint {
    get {return _storage._pts ?? TimePoint()}
    set {_uniqueStorage()._pts = newValue}
  }
  /// Returns true if `pts` has been explicitly set.
  public var hasPts: Bool {return _storage._pts != nil}
  /// Clears the value of `pts`. Subsequent reads from it will return its default value.
  public mutating func clearPts() {_uniqueStorage()._pts = nil}

  public var dts: TimePoint {
    get {return _storage._dts ?? TimePoint()}
    set {_uniqueStorage()._dts = newValue}
  }
  /// Returns true if `dts` has been explicitly set.
  public var hasDts: Bool {return _storage._dts != nil}
  /// Clears the value of `dts`. Subsequent reads from it will return its default value.
  public mutating func clearDts() {_uniqueStorage()._dts = nil}

  public var eventTime: TimePoint {
    get {return _storage._eventTime ?? TimePoint()}
    set {_uniqueStorage()._eventTime = newValue}
  }
  /// Returns true if `eventTime` has been explicitly set.
  public var hasEventTime: Bool {return _storage._eventTime != nil}
  /// Clears the value of `eventTime`. Subsequent reads from it will return its default value.
  public mutating func clearEventTime() {_uniqueStorage()._eventTime = nil}

  public var idAsset: String {
    get {return _storage._idAsset}
    set {_uniqueStorage()._idAsset = newValue}
  }

  public var idWorkspace: String {
    get {return _storage._idWorkspace}
    set {_uniqueStorage()._idWorkspace = newValue}
  }

  public var tokenWorkspace: String {
    get {return _storage._tokenWorkspace}
    set {_uniqueStorage()._tokenWorkspace = newValue}
  }

  public var buffer: Data {
    get {return _storage._buffer}
    set {_uniqueStorage()._buffer = newValue}
  }

  public var side: Dictionary<String,Data> {
    get {return _storage._side}
    set {_uniqueStorage()._side = newValue}
  }

  public var mediatype: MediaType {
    get {return _storage._mediatype}
    set {_uniqueStorage()._mediatype = newValue}
  }

  public var mediaformat: MediaFormat {
    get {return _storage._mediaformat}
    set {_uniqueStorage()._mediaformat = newValue}
  }

  ///map<string, string> eventInfo = 11;
  public var encoder: String {
    get {return _storage._encoder}
    set {_uniqueStorage()._encoder = newValue}
  }

  public var constituents: [MediaConstituent] {
    get {return _storage._constituents}
    set {_uniqueStorage()._constituents = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MediaConstituent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idAsset: String {
    get {return _storage._idAsset}
    set {_uniqueStorage()._idAsset = newValue}
  }

  public var pts: TimePoint {
    get {return _storage._pts ?? TimePoint()}
    set {_uniqueStorage()._pts = newValue}
  }
  /// Returns true if `pts` has been explicitly set.
  public var hasPts: Bool {return _storage._pts != nil}
  /// Clears the value of `pts`. Subsequent reads from it will return its default value.
  public mutating func clearPts() {_uniqueStorage()._pts = nil}

  public var dts: TimePoint {
    get {return _storage._dts ?? TimePoint()}
    set {_uniqueStorage()._dts = newValue}
  }
  /// Returns true if `dts` has been explicitly set.
  public var hasDts: Bool {return _storage._dts != nil}
  /// Clears the value of `dts`. Subsequent reads from it will return its default value.
  public mutating func clearDts() {_uniqueStorage()._dts = nil}

  public var duration: TimePoint {
    get {return _storage._duration ?? TimePoint()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {_uniqueStorage()._duration = nil}

  public var normalizedPts: TimePoint {
    get {return _storage._normalizedPts ?? TimePoint()}
    set {_uniqueStorage()._normalizedPts = newValue}
  }
  /// Returns true if `normalizedPts` has been explicitly set.
  public var hasNormalizedPts: Bool {return _storage._normalizedPts != nil}
  /// Clears the value of `normalizedPts`. Subsequent reads from it will return its default value.
  public mutating func clearNormalizedPts() {_uniqueStorage()._normalizedPts = nil}

  public var constituents: [MediaConstituent] {
    get {return _storage._constituents}
    set {_uniqueStorage()._constituents = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MediaType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "video"),
    1: .same(proto: "audio"),
    2: .same(proto: "image"),
    3: .same(proto: "data"),
    4: .same(proto: "subtitle"),
  ]
}

extension MediaFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "avc"),
    1: .same(proto: "hevc"),
    2: .same(proto: "aac"),
    3: .same(proto: "opus"),
    4: .same(proto: "av1"),
    5: .same(proto: "vp8"),
    6: .same(proto: "vp9"),
    7: .same(proto: "uncompressed"),
    8: .same(proto: "png"),
    9: .same(proto: "apng"),
    10: .same(proto: "jpg"),
    11: .same(proto: "gif"),
    12: .same(proto: "klv"),
    13: .same(proto: "srt"),
    14: .same(proto: "webvtt"),
    15: .same(proto: "utf8Text"),
  ]
}

extension MediaSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "rtmp"),
    1: .same(proto: "webrtc"),
    2: .same(proto: "httpPut"),
    3: .same(proto: "protobuf"),
    4: .same(proto: "httpGet"),
    5: .same(proto: "transcode"),
    6: .same(proto: "composition"),
    7: .same(proto: "web"),
    8: .same(proto: "output"),
    9: .same(proto: "flavor"),
    10: .same(proto: "file"),
    11: .same(proto: "text"),
  ]
}

extension CodedMediaSampleWire: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CodedMediaSampleWire"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pts"),
    2: .same(proto: "dts"),
    3: .same(proto: "eventTime"),
    4: .same(proto: "idAsset"),
    5: .same(proto: "idWorkspace"),
    6: .same(proto: "tokenWorkspace"),
    7: .same(proto: "buffer"),
    8: .same(proto: "side"),
    9: .same(proto: "mediatype"),
    10: .same(proto: "mediaformat"),
    12: .same(proto: "encoder"),
    14: .same(proto: "constituents"),
  ]

  fileprivate class _StorageClass {
    var _pts: TimePoint? = nil
    var _dts: TimePoint? = nil
    var _eventTime: TimePoint? = nil
    var _idAsset: String = String()
    var _idWorkspace: String = String()
    var _tokenWorkspace: String = String()
    var _buffer: Data = SwiftProtobuf.Internal.emptyData
    var _side: Dictionary<String,Data> = [:]
    var _mediatype: MediaType = .video
    var _mediaformat: MediaFormat = .avc
    var _encoder: String = String()
    var _constituents: [MediaConstituent] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pts = source._pts
      _dts = source._dts
      _eventTime = source._eventTime
      _idAsset = source._idAsset
      _idWorkspace = source._idWorkspace
      _tokenWorkspace = source._tokenWorkspace
      _buffer = source._buffer
      _side = source._side
      _mediatype = source._mediatype
      _mediaformat = source._mediaformat
      _encoder = source._encoder
      _constituents = source._constituents
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._pts)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._dts)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._eventTime)
        case 4: try decoder.decodeSingularStringField(value: &_storage._idAsset)
        case 5: try decoder.decodeSingularStringField(value: &_storage._idWorkspace)
        case 6: try decoder.decodeSingularStringField(value: &_storage._tokenWorkspace)
        case 7: try decoder.decodeSingularBytesField(value: &_storage._buffer)
        case 8: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &_storage._side)
        case 9: try decoder.decodeSingularEnumField(value: &_storage._mediatype)
        case 10: try decoder.decodeSingularEnumField(value: &_storage._mediaformat)
        case 12: try decoder.decodeSingularStringField(value: &_storage._encoder)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._constituents)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._pts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._dts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._eventTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._idAsset.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idAsset, fieldNumber: 4)
      }
      if !_storage._idWorkspace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idWorkspace, fieldNumber: 5)
      }
      if !_storage._tokenWorkspace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tokenWorkspace, fieldNumber: 6)
      }
      if !_storage._buffer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._buffer, fieldNumber: 7)
      }
      if !_storage._side.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: _storage._side, fieldNumber: 8)
      }
      if _storage._mediatype != .video {
        try visitor.visitSingularEnumField(value: _storage._mediatype, fieldNumber: 9)
      }
      if _storage._mediaformat != .avc {
        try visitor.visitSingularEnumField(value: _storage._mediaformat, fieldNumber: 10)
      }
      if !_storage._encoder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._encoder, fieldNumber: 12)
      }
      if !_storage._constituents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._constituents, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CodedMediaSampleWire, rhs: CodedMediaSampleWire) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pts != rhs_storage._pts {return false}
        if _storage._dts != rhs_storage._dts {return false}
        if _storage._eventTime != rhs_storage._eventTime {return false}
        if _storage._idAsset != rhs_storage._idAsset {return false}
        if _storage._idWorkspace != rhs_storage._idWorkspace {return false}
        if _storage._tokenWorkspace != rhs_storage._tokenWorkspace {return false}
        if _storage._buffer != rhs_storage._buffer {return false}
        if _storage._side != rhs_storage._side {return false}
        if _storage._mediatype != rhs_storage._mediatype {return false}
        if _storage._mediaformat != rhs_storage._mediaformat {return false}
        if _storage._encoder != rhs_storage._encoder {return false}
        if _storage._constituents != rhs_storage._constituents {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MediaConstituent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MediaConstituent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "idAsset"),
    3: .same(proto: "pts"),
    4: .same(proto: "dts"),
    5: .same(proto: "duration"),
    6: .same(proto: "normalizedPts"),
    7: .same(proto: "constituents"),
  ]

  fileprivate class _StorageClass {
    var _idAsset: String = String()
    var _pts: TimePoint? = nil
    var _dts: TimePoint? = nil
    var _duration: TimePoint? = nil
    var _normalizedPts: TimePoint? = nil
    var _constituents: [MediaConstituent] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _idAsset = source._idAsset
      _pts = source._pts
      _dts = source._dts
      _duration = source._duration
      _normalizedPts = source._normalizedPts
      _constituents = source._constituents
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._idAsset)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._pts)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._dts)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._duration)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._normalizedPts)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._constituents)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._idAsset.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idAsset, fieldNumber: 1)
      }
      if let v = _storage._pts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._dts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._normalizedPts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._constituents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._constituents, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MediaConstituent, rhs: MediaConstituent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._idAsset != rhs_storage._idAsset {return false}
        if _storage._pts != rhs_storage._pts {return false}
        if _storage._dts != rhs_storage._dts {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._normalizedPts != rhs_storage._normalizedPts {return false}
        if _storage._constituents != rhs_storage._constituents {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
